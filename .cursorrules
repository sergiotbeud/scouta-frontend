# Scouta Frontend - Coding Rules

## ğŸ—ï¸ Arquitectura

### Hexagonal Architecture (Adaptado para Frontend)
- **Domain Layer**: Entidades y tipos del dominio
- **Ports**: Interfaces que definen contratos (API Client, Store)
- **Adapters**: Implementaciones concretas (Axios, Zustand)
- **Use Cases**: Hooks personalizados que encapsulan lÃ³gica
- **Components**: Componentes React puros y presentacionales

### Estructura de Carpetas
```
app/              # Next.js App Router (pÃ¡ginas)
components/       # Componentes React reutilizables
domain/           # Entidades y tipos del dominio
ports/            # Interfaces (contratos)
adapters/         # Implementaciones (API, Store)
use-cases/        # Custom hooks (lÃ³gica de negocio)
store/            # Estado global (Zustand)
```

## ğŸ“ TypeScript

### Reglas Generales
- **Strict Mode**: Siempre activado
- **No `any`**: Usar tipos especÃ­ficos o `unknown`
- **Interfaces sobre Types**: Preferir interfaces para objetos
- **Type Safety**: Tipar props, estados y funciones

### Nomenclatura
- **Componentes**: PascalCase (`LoginForm`, `PlayerCard`)
- **Hooks**: camelCase con prefijo `use` (`useLogin`, `useAuth`)
- **Funciones**: camelCase (`fetchUser`, `validateEmail`)
- **Constantes**: UPPER_SNAKE_CASE (`API_URL`, `MAX_RETRIES`)
- **Archivos**: kebab-case (`login-form.tsx`, `auth-store.ts`)

## âš›ï¸ React

### Componentes
- **Functional Components**: Siempre usar funciones, no clases
- **Props**: Tipar con interfaces o types
- **Hooks**: Usar hooks personalizados para lÃ³gica compleja
- **MemoizaciÃ³n**: Usar `useMemo` y `useCallback` cuando sea necesario

### Estado
- **Local State**: `useState` para estado del componente
- **Global State**: Zustand para estado compartido
- **Server State**: Considerar React Query para datos del servidor

## ğŸ¨ Tailwind CSS

### Reglas
- **Utility First**: Preferir clases de Tailwind sobre CSS custom
- **Dark Mode**: Usar `dark:` prefix para estilos oscuros
- **Responsive**: Mobile-first approach
- **Colores**: Usar colores del tema definidos en `tailwind.config.js`

### Clases Comunes
- **Containers**: `container mx-auto px-4`
- **Cards**: `bg-dark-surface border border-dark-border rounded-lg p-6`
- **Buttons**: `bg-primary-500 hover:bg-primary-600 text-white px-4 py-2 rounded`
- **Inputs**: `bg-dark-elevated border border-dark-border text-white rounded px-4 py-2`

## ğŸ“¦ Next.js 14

### App Router
- **Pages**: Usar `app/` directory, no `pages/`
- **Layouts**: Usar `layout.tsx` para layouts compartidos
- **Loading**: Usar `loading.tsx` para estados de carga
- **Error**: Usar `error.tsx` para manejo de errores

### Data Fetching
- **Server Components**: Por defecto, usar Server Components
- **Client Components**: Marcar con `'use client'` cuando sea necesario
- **API Routes**: Usar para endpoints internos si es necesario

## ğŸ”’ Seguridad

### ValidaciÃ³n
- **Zod**: Para validaciÃ³n de formularios y datos
- **React Hook Form**: Para manejo de formularios
- **Validar en Frontend**: Pero nunca confiar solo en esto

### AutenticaciÃ³n
- **JWT**: Almacenar en localStorage o cookies httpOnly
- **ProtecciÃ³n de Rutas**: Middleware de Next.js
- **Tokens**: Refrescar automÃ¡ticamente cuando expire

## ğŸ§ª Testing

### Pruebas
- **Unit Tests**: Para funciones y hooks
- **Component Tests**: Para componentes React
- **E2E Tests**: Para flujos completos (opcional)

## ğŸ“š CÃ³digo

### Comentarios
- **JSDoc**: Para funciones y componentes pÃºblicos
- **Explicar "por quÃ©"**: No "quÃ©"
- **Eliminar cÃ³digo comentado**

### Formato
- **Prettier**: Formateo automÃ¡tico
- **ESLint**: Linting
- **Consistencia**: Seguir el estilo del proyecto

## ğŸš« NO Hacer

- âŒ No usar `any` en TypeScript
- âŒ No hacer lÃ³gica de negocio en componentes
- âŒ No acceder directamente a APIs desde componentes
- âŒ No usar `console.log` en producciÃ³n
- âŒ No hardcodear valores (usar config/env)
- âŒ No crear dependencias circulares
- âŒ No usar clases de CSS custom sin necesidad

## âœ… SÃ­ Hacer

- âœ… Usar TypeScript strict mode
- âœ… Validar formularios con Zod
- âœ… Manejar estados de carga y error
- âœ… Usar componentes reutilizables
- âœ… Seguir arquitectura hexagonal
- âœ… Mantener componentes pequeÃ±os y enfocados
- âœ… Usar nombres descriptivos
- âœ… Documentar componentes complejos







